import { Request, Response } from 'express';
import { AuthService } from '../services/authService';
import { body, validationResult } from 'express-validator';

export class AuthController {
    /**
     * User login
     */
    static async login(req: Request, res: Response) {
        try {
            // Validate request
            await body('email')
                .isEmail()
                .normalizeEmail()
                .withMessage('Valid email is required')
                .run(req);
                
            await body('password')
                .notEmpty()
                .withMessage('Password is required')
                .run(req);

            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                return res.status(400).json({
                    success: false,
                    message: 'Validation failed',
                    errors: errors.array()
                });
            }

            const { email, password } = req.body;
            
            // Get device info from request
            const deviceInfo = {
                userAgent: req.headers['user-agent'],
                ip: req.ip,
                timestamp: new Date().toISOString()
            };

            const result = await AuthService.login(email, password, deviceInfo);

            if (!result.success) {
                return res.status(401).json({
                    success: false,
                    message: result.message
                });
            }

            // Set refresh token as httpOnly cookie
            res.cookie('refreshToken', result.tokens?.refreshToken, {
                httpOnly: true,
                secure: process.env.NODE_ENV === 'production',
                sameSite: 'strict',
                maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
            });

            // Return success without refresh token in body
            return res.status(200).json({
                success: true,
                message: 'Login successful',
                data: {
                    user: result.user,
                    partner: result.partner,
                    accessToken: result.tokens?.accessToken,
                    expiresIn: result.tokens?.expiresIn
                }
            });
        } catch (error) {
            console.error('Login error:', error);
            return res.status(500).json({
                success: false,
                message: 'Internal server error'
            });
        }
    }

    /**
     * User logout
     */
    static async logout(req: Request, res: Response) {
        try {
            const refreshToken = req.cookies.refreshToken;
            const userId = req.user?.userId;

            if (!refreshToken || !userId) {
                return res.status(400).json({
                    success: false,
                    message: 'No active session found'
                });
            }

            const result = await AuthService.logout(userId, refreshToken);

            // Clear refresh token cookie
            res.clearCookie('refreshToken');

            return res.status(200).json(result);
        } catch (error) {
            console.error('Logout error:', error);
            return res.status(500).json({
                success: false,
                message: 'Internal server error'
            });
        }
    }

    /**
     * Register new sub-account
     */
    static async register(req: Request, res: Response) {
        try {
            // Validate request
            await body('email')
                .isEmail()
                .normalizeEmail()
                .withMessage('Valid email is required')
                .run(req);
                
            await body('password')
                .isLength({ min: 8 })
                .withMessage('Password must be at least 8 characters long')
                .run(req);

            await body('firstName')
                .optional()
                .isLength({ min: 1, max: 100 })
                .withMessage('First name must be between 1 and 100 characters')
                .run(req);

            await body('lastName')
                .optional()
                .isLength({ min: 1, max: 100 })
                .withMessage('Last name must be between 1 and 100 characters')
                .run(req);

            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                return res.status(400).json({
                    success: false,
                    message: 'Validation failed',
                    errors: errors.array()
                });
            }

            const { email, password, firstName, lastName } = req.body;
            
            // Get partner ID from authenticated user
            const partnerId = req.user?.partnerId;
            
            if (!partnerId) {
                return res.status(400).json({
                    success: false,
                    message: 'Partner ID is required'
                });
            }

            // Only admin users can create sub-accounts
            if (req.user?.role !== 'admin') {
                return res.status(403).json({
                    success: false,
                    message: 'Only admin users can create sub-accounts'
                });
            }

            const result = await AuthService.register(
                partnerId,
                email,
                password,
                firstName,
                lastName,
                'sub'
            );

            const statusCode = result.success ? 201 : 400;
            return res.status(statusCode).json(result);
        } catch (error) {
            console.error('Registration error:', error);
            return res.status(500).json({
                success: false,
                message: 'Internal server error'
            });
        }
    }

    /**
     * Refresh access token
     */
    static async refreshToken(req: Request, res: Response) {
        try {
            const refreshToken = req.cookies.refreshToken;

            if (!refreshToken) {
                return res.status(401).json({
                    success: false,
                    message: 'Refresh token not found'
                });
            }

            const result = await AuthService.refreshToken(refreshToken);

            if (!result.success) {
                res.clearCookie('refreshToken');
                return res.status(401).json({
                    success: false,
                    message: result.message
                });
            }

            // Set new refresh token as httpOnly cookie
            res.cookie('refreshToken', result.tokens?.refreshToken, {
                httpOnly: true,
                secure: process.env.NODE_ENV === 'production',
                sameSite: 'strict',
                maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
            });

            return res.status(200).json({
                success: true,
                message: 'Token refreshed successfully',
                data: {
                    user: result.user,
                    partner: result.partner,
                    accessToken: result.tokens?.accessToken,
                    expiresIn: result.tokens?.expiresIn
                }
            });
        } catch (error) {
            console.error('Token refresh error:', error);
            return res.status(500).json({
                success: false,
                message: 'Internal server error'
            });
        }
    }

    /**
     * Get current user profile
     */
    static async profile(req: Request, res: Response) {
        try {
            if (!req.user) {
                return res.status(401).json({
                    success: false,
                    message: 'User not authenticated'
                });
            }

            return res.status(200).json({
                success: true,
                data: {
                    user: {
                        userId: req.user.userId,
                        partnerId: req.user.partnerId,
                        email: req.user.email,
                        role: req.user.role
                    }
                }
            });
        } catch (error) {
            console.error('Profile error:', error);
            return res.status(500).json({
                success: false,
                message: 'Internal server error'
            });
        }
    }

    /**
     * Validate token
     */
    static async validateToken(req: Request, res: Response) {
        try {
            // If we reach here, the token is valid (middleware already validated it)
            return res.status(200).json({
                success: true,
                message: 'Token is valid',
                data: {
                    valid: true,
                    user: req.user
                }
            });
        } catch (error) {
            console.error('Token validation error:', error);
            return res.status(500).json({
                success: false,
                message: 'Internal server error'
            });
        }
    }
} 